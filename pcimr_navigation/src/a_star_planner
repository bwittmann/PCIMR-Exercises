#!/usr/bin/env python3

import rospy
import numpy as np
from threading import Lock

from visualization_msgs.msg import Marker 
from nav_msgs.msg import OccupancyGrid, Path
from geometry_msgs.msg import Point, Quaternion, PoseStamped


class AStarPathPlanner():

    def __init__(self):
        # Initialize constants
        self.HEIGHT = 20
        self.WIDTH = 20

        # Initilize instance variables
        self.sim_lock = Lock()
        self.map = np.array([])
        self.robot_pos = None
        self.is_goal_valid = False
        self.goal = None
        self.goal_cache = None

        # Initialize Publishers
        self.pub_path = rospy.Publisher('/global_path', Path, queue_size=10)
        self.pub_goal = rospy.Publisher('/visualization/goal', Marker, queue_size=10)
        self.pub_plan = rospy.Publisher('/visualization/plan', Marker, queue_size=10) # not too sure about this one

        # Initialize Subscribers
        self.sub_map = rospy.Subscriber('/map', OccupancyGrid, self._cb_map)
        self.sub_robot_pos = rospy.Subscriber('/robot_pos', Point, self._cb_robot_pos)
        self.sub_goal = rospy.Subscriber('/move_base_simple/goal', PoseStamped, self._cb_goal)

        # Setup messages for publishing
        self.msg_goal_marker = Marker()
        self.msg_goal_marker.header.frame_id = "map"
        self.msg_goal_marker.ns = "navigation"
        self.msg_goal_marker.id = 0
        self.msg_goal_marker.type = Marker.CUBE
        self.msg_goal_marker.action = Marker.ADD
        self.msg_goal_marker.scale.x = 1
        self.msg_goal_marker.scale.y = 1
        self.msg_goal_marker.scale.z = 0.2
        self.msg_goal_marker.color.a = 1.0
        self.msg_goal_marker.color.r = 1.0
        self.msg_goal_marker.color.g = 0.0
        self.msg_goal_marker.color.b = 0.0
        self.msg_goal_marker.pose.orientation = Quaternion(0, 0, 0, 1)

        self.msg_plan_marker = Marker()
        self.msg_plan_marker.header.frame_id = "map"
        self.msg_plan_marker.ns = "navigation"
        self.msg_plan_marker.id = 0
        self.msg_plan_marker.type = Marker.LINE_STRIP
        self.msg_plan_marker.action = Marker.ADD
        self.msg_plan_marker.scale.x = 0.3
        self.msg_plan_marker.color.a = 0.5
        self.msg_plan_marker.color.r = 0.0
        self.msg_plan_marker.color.g = 1.0
        self.msg_plan_marker.color.b = 0.0
        self.msg_plan_marker.pose.orientation = Quaternion(0, 0, 0, 1)

        self.msg_path = Path()
        self.msg_path.header.frame_id = 'map'

        '''
        self.msg_pose = PoseStamped()
        self.msg_pose.header.frame_id = 'map'
        self.msg_pose.pose.position.z = 0
        self.msg_pose.pose.orientation = Quaternion(0, 0, 0, 1)
        '''


    def _cb_robot_pos(self, msg):
        self.sim_lock.acquire()
        self.robot_pos = (int(msg.y) , int(msg.x))
        self.sim_lock.release()

    def _cb_map(self, msg):
        self.sim_lock.acquire()
        self.map = np.array(msg.data).reshape(self.HEIGHT, self.WIDTH)
        self.sim_lock.release()

    def _cb_goal(self, msg):
        self.sim_lock.acquire()
        self.goal = (int(np.floor(msg.pose.position.y)), int(np.floor(msg.pose.position.x)))
        self.sim_lock.release()

    def _check_goal(self):
        if self.goal != None:
            if self.map[self.goal[0], self.goal[1]] == 0:
                rospy.loginfo('Valid goal.')
                self.is_goal_valid = True
            else:
                rospy.loginfo('Invalid goal. Please select a new one.')
                self.is_goal_valid = False


    class Node():
        def __init__(self, pos, parent, goal, start):
            self.pos = pos
            self.parent = parent
            self.val = self._manhattan_distance(self.pos, goal) + self._manhattan_distance(self.pos, start)

        @staticmethod
        def _manhattan_distance(pos1, pos2):
            return abs(pos1[1] - pos2[1]) + abs(pos1[0] - pos2[0])

        def __gt__(self, other):
            return self.val > other.val

        def __repr__(self):
            return str(self.pos)


    def _run_astar(self):
        self.queue = [self.Node(self.robot_pos, None, self.goal, self.robot_pos)]
        self.explored = [self.robot_pos]

        i = 0
        while i < 200:
            i += 1

            current_node = self.queue.pop(0)

            try:
                if self.map[current_node.pos[0] + 1, current_node.pos[1]] == 0 and (current_node.pos[0] + 1, current_node.pos[1]) not in self.explored:
                    self.explored.append((current_node.pos[0] + 1, current_node.pos[1]))
                    self.queue.append(self.Node((current_node.pos[0] + 1, current_node.pos[1]), current_node, self.goal, self.robot_pos))
                if self.map[current_node.pos[0] - 1, current_node.pos[1]] == 0 and (current_node.pos[0] - 1, current_node.pos[1]) not in self.explored:
                    self.explored.append((current_node.pos[0] - 1, current_node.pos[1]))
                    self.queue.append(self.Node((current_node.pos[0] - 1, current_node.pos[1]), current_node, self.goal, self.robot_pos))
                if self.map[current_node.pos[0], current_node.pos[1] + 1] == 0 and [current_node.pos[0], current_node.pos[1] + 1] not in self.explored:
                    self.explored.append((current_node.pos[0], current_node.pos[1] + 1))
                    self.queue.append(self.Node((current_node.pos[0], current_node.pos[1] + 1), current_node, self.goal, self.robot_pos))
                if self.map[current_node.pos[0], current_node.pos[1] - 1] == 0 and (current_node.pos[0], current_node.pos[1] - 1) not in self.explored:
                    self.explored.append((current_node.pos[0], current_node.pos[1] - 1))
                    self.queue.append(self.Node((current_node.pos[0], current_node.pos[1] - 1), current_node, self.goal, self.robot_pos))
            except IndexError:
                pass


            '''
            print("----------------------")
            print("Current Node :", current_node)
            print("Queue: ", self.queue)
            print("Explored: ", self.explored)
            '''

            if current_node.pos == self.goal:
                rospy.loginfo('Path between current position and goal found.')
                path = []
                while True:
                    path.append(current_node.pos)
                    current_node = current_node.parent
                    if current_node == None:
                        print(path[::-1])
                        break
                break

            if len(self.queue) == 0:
                rospy.loginfo('Connection between current position and goal not possible.')
                break

            self.queue.sort()

        return path


    def main(self, rate=1):
        while not rospy.is_shutdown():

            if self.goal != self.goal_cache:
                self._check_goal()

                if self.is_goal_valid:
                    print('Start: ',self.robot_pos)
                    print('Goal: ', self.goal)
                    path = self._run_astar()


                    # Publish path and goal
                    self.msg_goal_marker.pose.position.x = self.goal[1] + 0.5
                    self.msg_goal_marker.pose.position.y = self.goal[0] + 0.5
                    self.pub_goal.publish(self.msg_goal_marker)

                    self.msg_plan_marker.points.clear()
                    for cell in path:
                        self.msg_plan_marker.points.append(Point(cell[1] + 0.5, cell[0] + 0.5, 0))
                    self.pub_plan.publish(self.msg_plan_marker)

                    self.msg_path.poses.clear()
                    for cell in path[::-1]:
                        print(cell)
                        self.msg_pose = PoseStamped()
                        self.msg_pose.header.frame_id = 'map'
                        self.msg_pose.pose.position.z = 0
                        self.msg_pose.pose.orientation = Quaternion(0, 0, 0, 1)
                        self.msg_pose.pose.position.x = cell[1] # + 0.5
                        self.msg_pose.pose.position.y = cell[0] # + 0.5
                        self.msg_path.poses.append(self.msg_pose)
                    self.pub_path.publish(self.msg_path)



            self.goal_cache = self.goal

    
            rospy.sleep(1/rate)




if __name__ == "__main__":
    rospy.init_node('a_star_planner')

    a_star_planner = AStarPathPlanner()
    a_star_planner.main()

