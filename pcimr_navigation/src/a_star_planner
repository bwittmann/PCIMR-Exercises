#!/usr/bin/env python3

import rospy
import numpy as np
from threading import Lock

from visualization_msgs.msg import Marker 
from nav_msgs.msg import OccupancyGrid, Path
from geometry_msgs.msg import Point, Quaternion, PoseStamped


class AStarPathPlanner():
    """
    Class that implements an A-Star path planner, which can be used as a ROS node for navigation.
    """

    def __init__(self):
        """
        Initialisation of an instance of the AStarPathPlanner class, including all its publishers
        and subscribers.
        """
        # Initialize constants
        self.HEIGHT = 20
        self.WIDTH = 20

        # Initilize instance variables
        self.sim_lock = Lock()
        self.map = np.array([])
        self.robot_pos = None
        self.is_goal_valid = False
        self.goal = None
        self.goal_cache = None

        # Initialize Publishers
        self.pub_path = rospy.Publisher('/global_path', Path, queue_size=10, latch=True)
        self.pub_goal = rospy.Publisher('/visualization/goal', Marker, queue_size=10)
        self.pub_plan = rospy.Publisher('/visualization/plan', Marker, queue_size=10)

        # Initialize Subscribers
        self.sub_map = rospy.Subscriber('/map', OccupancyGrid, self._cb_map)
        self.sub_robot_pos = rospy.Subscriber('/robot_pos', Point, self._cb_robot_pos)
        self.sub_goal = rospy.Subscriber('/move_base_simple/goal', PoseStamped, self._cb_goal)

        # Setup messages for publishing
        self.msg_goal_marker = Marker()
        self.msg_goal_marker.header.frame_id = "map"
        self.msg_goal_marker.ns = "navigation"
        self.msg_goal_marker.id = 0
        self.msg_goal_marker.type = Marker.CUBE
        self.msg_goal_marker.action = Marker.ADD
        self.msg_goal_marker.scale.x = 1
        self.msg_goal_marker.scale.y = 1
        self.msg_goal_marker.scale.z = 0.2
        self.msg_goal_marker.color.a = 1.0
        self.msg_goal_marker.color.r = 1.0
        self.msg_goal_marker.color.g = 0.0
        self.msg_goal_marker.color.b = 0.0
        self.msg_goal_marker.pose.orientation = Quaternion(0, 0, 0, 1)

        self.msg_plan_marker = Marker()
        self.msg_plan_marker.header.frame_id = "map"
        self.msg_plan_marker.ns = "navigation"
        self.msg_plan_marker.id = 0
        self.msg_plan_marker.type = Marker.LINE_STRIP
        self.msg_plan_marker.action = Marker.ADD
        self.msg_plan_marker.scale.x = 0.3
        self.msg_plan_marker.color.a = 0.5
        self.msg_plan_marker.color.r = 0.0
        self.msg_plan_marker.color.g = 1.0
        self.msg_plan_marker.color.b = 0.0
        self.msg_plan_marker.pose.orientation = Quaternion(0, 0, 0, 1)

        self.msg_path = Path()
        self.msg_path.header.frame_id = 'map'


    def _cb_robot_pos(self, msg):
        """
        Callback function for receiving the current robot position.

        @param msg: Message containing a Point describing the robot position (x, y, z).
        """
        self.sim_lock.acquire()
        self.robot_pos = (int(msg.y) , int(msg.x))
        self.sim_lock.release()

    def _cb_map(self, msg):
        """
        Callback function for receiving the current map.

        @param msg: Message containing a OccupancyGrid describing the discretized world.
        """
        self.sim_lock.acquire()
        self.map = np.array(msg.data).reshape(self.HEIGHT, self.WIDTH)
        self.sim_lock.release()

    def _cb_goal(self, msg):
        """
        Callback function for receiving the current goal position.

        @param msg: Message containing a PoseStamped with position and orientation
                    of the goal position.
        """
        self.sim_lock.acquire()
        self.goal = (int(np.floor(msg.pose.position.y)), int(np.floor(msg.pose.position.x)))
        self.sim_lock.release()

    def _check_goal(self):
        """
        Method for checking if the goal is in the freespace of the map and therefore is valid.
        """
        if self.goal != None:
            if self.map[self.goal[0], self.goal[1]] == 0:
                rospy.loginfo('Valid goal.')
                self.is_goal_valid = True
            else:
                rospy.loginfo('Invalid goal. Please select a new one.')
                self.is_goal_valid = False


    class Node():
        """
        Class that is necessary for the A-Star algorithm and represents a node that can be used for 
        graph based path search.
        """

        def __init__(self, pos, parent, goal, start):
            """
            Initialization of an instance of the node class.
            """
            self.pos = pos
            self.parent = parent
            self.val = self._manhattan_distance(self.pos, goal) + self._manhattan_distance(self.pos, start)

        @staticmethod
        def _manhattan_distance(pos1, pos2):
            """
            Static method used to compute the cost of a node, which represents the Manhattan distance between two
            positions. 
            """
            return abs(pos1[1] - pos2[1]) + abs(pos1[0] - pos2[0])

        def __gt__(self, other):
            """
            Dunder method that allows the use of the '>' comparison operator between two nodes.
            """
            return self.val > other.val

        def __repr__(self):
            """
            Dunder method that returns a printable version of an instance.
            """
            return str(self.pos)


    def _run_astar(self):
        """
        Method to run the A-Star algorithm.

        @return: A list of the shortest path - based on A-Star - between self.goal and self.robot_pos.
        """
        # Create lists for the explored nodes (based on position) and for nodes at frontiers
        self.queue = [self.Node(self.robot_pos, None, self.goal, self.robot_pos)]
        self.explored = [self.robot_pos]

        while True:
            # Get the node with the smallest cost from the queue
            current_node = self.queue.pop(0)

            # Add surrounding nodes that have not been explored before and are in the free space to the queue and the explored list
            try:
                if self.map[current_node.pos[0] + 1, current_node.pos[1]] == 0 and (current_node.pos[0] + 1, current_node.pos[1]) not in self.explored:
                    self.explored.append((current_node.pos[0] + 1, current_node.pos[1]))
                    self.queue.append(self.Node((current_node.pos[0] + 1, current_node.pos[1]), current_node, self.goal, self.robot_pos))
            except IndexError:
                pass

            try:       
                if self.map[current_node.pos[0] - 1, current_node.pos[1]] == 0 and (current_node.pos[0] - 1, current_node.pos[1]) not in self.explored:
                    self.explored.append((current_node.pos[0] - 1, current_node.pos[1]))
                    self.queue.append(self.Node((current_node.pos[0] - 1, current_node.pos[1]), current_node, self.goal, self.robot_pos))
            except IndexError:
                pass

            try:
                if self.map[current_node.pos[0], current_node.pos[1] + 1] == 0 and [current_node.pos[0], current_node.pos[1] + 1] not in self.explored:
                    self.explored.append((current_node.pos[0], current_node.pos[1] + 1))
                    self.queue.append(self.Node((current_node.pos[0], current_node.pos[1] + 1), current_node, self.goal, self.robot_pos))
            except IndexError:
                pass
                
            try:
                if self.map[current_node.pos[0], current_node.pos[1] - 1] == 0 and (current_node.pos[0], current_node.pos[1] - 1) not in self.explored:
                    self.explored.append((current_node.pos[0], current_node.pos[1] - 1))
                    self.queue.append(self.Node((current_node.pos[0], current_node.pos[1] - 1), current_node, self.goal, self.robot_pos))
            except IndexError:
                pass

            # Additional print statements for demonstration of the underlying processes
            #print("----------------------")
            #print("Current Node :", current_node)
            #print("Queue: ", self.queue)
            #print("Explored: ", self.explored)
            
            # Check if the current node is the goal node
            if current_node.pos == self.goal:
                rospy.loginfo('Path between current position and goal found.')
                path = []
                while True:
                    path.append(current_node.pos)
                    current_node = current_node.parent
                    if current_node == None:
                        break
                break

            # Check if the queue is empty, which means that a path could not be found
            if len(self.queue) == 0:
                rospy.loginfo('Connection between current position and goal not possible.')
                break

            # Sort the queue to pop the node with the smallest cost in the next iteration
            self.queue.sort()
        return path


    def main(self, rate=1):
        """
        Main method, which should be used to run the node and the A-Star algorithm.
        """
        while not rospy.is_shutdown():

            # Check if the current goal is still the same as an iteration before
            if self.goal != self.goal_cache:
                self._check_goal()

                if self.is_goal_valid:
                    print('Start: ',self.robot_pos)
                    print('Goal: ', self.goal)

                    path = self._run_astar()
                    print(path[::-1])

                    # Publish path and goal
                    self.msg_goal_marker.pose.position.x = self.goal[1] + 0.5
                    self.msg_goal_marker.pose.position.y = self.goal[0] + 0.5
                    self.pub_goal.publish(self.msg_goal_marker)

                    self.msg_plan_marker.points.clear()
                    for cell in path:
                        self.msg_plan_marker.points.append(Point(cell[1] + 0.5, cell[0] + 0.5, 0))
                    self.pub_plan.publish(self.msg_plan_marker)

                    self.msg_path.poses.clear()
                    for cell in path[::-1]:
                        self.msg_pose = PoseStamped()
                        self.msg_pose.header.frame_id = 'map'
                        self.msg_pose.pose.position.z = 0
                        self.msg_pose.pose.orientation = Quaternion(0, 0, 0, 1)
                        self.msg_pose.pose.position.x = cell[1] # + 0.5
                        self.msg_pose.pose.position.y = cell[0] # + 0.5
                        self.msg_path.poses.append(self.msg_pose)
                    self.pub_path.publish(self.msg_path)

            self.goal_cache = self.goal
            rospy.sleep(1/rate)


if __name__ == "__main__":
    # Create a node of the A-Star path planner
    rospy.init_node('a_star_planner')

    a_star_planner = AStarPathPlanner()
    a_star_planner.main()

